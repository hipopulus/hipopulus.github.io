<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Hipoplar</title>
 <link href="http://blog.hipoplar.me/atom.xml" rel="self"/>
 <link href="http://blog.hipoplar.me"/>
 <updated>2015-06-24T21:53:05+08:00</updated>
 <author>
   <name>Vincent Yang</name>
   <email>soda1015@foxmail.com</email>
 </author>

 
 <entry>
   <title>Objective-C学习备忘－需要研究的问题</title>
   <link href="http://blog.hipoplar.me/2015/06/oc-study-list.html"/>
   <updated>2015-06-15T00:00:00+08:00</updated>
   <id>/2015/06/oc-study-list</id>
   <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;h3&gt;下面的&lt;code&gt;|&lt;/code&gt;符号是什么意思？&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;static NSStringCompareOptions comparisonOptions = NSCaseInsensitiveSearch | NSNumericSearch | NSWidthInsensitiveSearch | NSForcedOrderingSearch;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://nshipster.com/ns_enum-ns_options/&quot;&gt;http://nshipster.com/ns_enum-ns_options/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3&gt;CoreFoundation的CFAvailability.h文件中关于&lt;code&gt;CF_ENUM&lt;/code&gt;和&lt;code&gt;CF_OPTIONS&lt;/code&gt;的宏定义的语法如何理解：&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#if (__cplusplus &amp;amp;&amp;amp; __cplusplus &amp;gt;= 201103L &amp;amp;&amp;amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;amp;&amp;amp; __has_feature(objc_fixed_enum))
#define CF_ENUM(_type, _name) enum _name : _type _name; enum _name : _type
#if (__cplusplus)
#define CF_OPTIONS(_type, _name) _type _name; enum : _type
#else
#define CF_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type
#endif
#else
#define CF_ENUM(_type, _name) _type _name; enum
#define CF_OPTIONS(_type, _name) _type _name; enum
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;问题已解决，下面是思考过程：&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;例如，要定义一个包含四个季节的枚举常量，先从标准C的定义开始：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  typedef enum Season : NSInteger Season;
  enum Season : NSInteger { Spring, Summer, Autumn, Winter };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  Season a = Autumn;
  NSLog(@&amp;quot;%ld&amp;quot;, a);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果为：2&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;接下来，用宏定义重写：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  #define SeasonList(_season, _type) enum _season : _type _season; enum _season : _type
  typedef SeasonList(Season, NSUInteger) { Spring, Summer, Autumn, Winter };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  Season a = Autumn;
  NSLog(@&amp;quot;%ld&amp;quot;, a);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果为：2，和上面的标准定义的结果相同。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;
</content>
 </entry>
 
 <entry>
   <title>Objective-C学习备忘</title>
   <link href="http://blog.hipoplar.me/2015/06/oc-points-first-met.html"/>
   <updated>2015-06-15T00:00:00+08:00</updated>
   <id>/2015/06/oc-points-first-met</id>
   <content type="html">&lt;hr&gt;
</content>
 </entry>
 
 <entry>
   <title>Swift学习备忘</title>
   <link href="http://blog.hipoplar.me/2015/06/swift-points-first-met.html"/>
   <updated>2015-06-10T00:00:00+08:00</updated>
   <id>/2015/06/swift-points-first-met</id>
   <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;var aString: String! = &amp;quot;Hello, World!&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Error handling&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Assertion&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;===&lt;/code&gt; 和 &lt;code&gt;!==&lt;/code&gt; 用来比较两个&lt;strong&gt;class的实例的引用&lt;/strong&gt;是否相同 &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;??&lt;/code&gt;用来为Optional实例解包，&lt;code&gt;a ?? b&lt;/code&gt; 等效于 &lt;code&gt;if a != nil ? a! : b&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift中的字符类型为&lt;code&gt;Character&lt;/code&gt;，声明时需注明数据类型，否则编译器会把它当作String处理：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var aCharacter: Character = &amp;quot;A&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unicode在String和Character中的语法是&lt;code&gt;\{n}&lt;/code&gt;，n代表1个16进制的Unicode码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var aString = &amp;quot;\u{41}\u{42}\u{43}&amp;quot;
var aCharacer: Character = &amp;quot;\u{41}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有些字符是可以组合，形成新的字符，并且新组成的字符的长度仍然是1：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var aCharacer: Character = &amp;quot;\u{65}\u{301}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由于Swift的更新，获取一个String实例的字符数量的方法需要验证，官方文档说是String不在遵循&lt;code&gt;CollectionType&lt;/code&gt;协议，今后需要采用最后一种方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var aString = &amp;quot;Swift&amp;quot;
var stringCount = countElements(aString)
var stringCount = count(aString)
var stringCount = aString.characters.count        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结构体属于值类型，类属于引用类型。值类型的变量或常量传递的是它的copy，引用类型传递的是它的引用。值类型里可以定义引用类型的属性，该引用类型的属性传递的仍然是它的引用，当然这种结构在应用上是不合理的，值类型包含的属性应该同样是值类型：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class SimpleClass {
    var description = &amp;quot;This is a simple class&amp;quot;
} 

struct SimpleStruct {
    var description = &amp;quot;This is a simple structure&amp;quot;
    var c = SimpleClass()
}  

var struct1 = SimpleStruct()
var struct2 = struct1

struct1.description = &amp;quot;Changed&amp;quot;
struct1.c.description = &amp;quot;Changed&amp;quot;

println(struct2.description)
println(struct2.c.description)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;let表示声明一个常量，常量在初始化之后，不可以再被修改。如果let声明了一个引用类型的常量，表示它不可以被重新引用一个实例，但是实例所包含的属性变量是可以被修改的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Person {
    var name = &amp;quot;&amp;quot;
    init(name: String) {
        self.name = name
    }
}

let person = Person(name: &amp;quot;Lisa&amp;quot;)
person.name = &amp;quot;Jacky&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Objectiv-C只可以在class中定义类方法，而Swift的类、结构体、枚举类型里都可以定义类方法，在func前面添加static关键声明，class类型中也可以用class关键声明，它的子类可以重写class修饰的父类方法&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;struct Point {
    static func moveBy(x: Int, y: Int) {}
}

enum SimpleEnum {
    case One, Two, Three
    static func doSomething() {}
}

class SimpleClass {
    static func test() {}
    class func doSomething() {}
}

class SubClass: SimpleClass {
    override func doSomething() {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结构体类型会自动生成初始化器：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;struct Size {
    var width: Float
    var height: Float
}

var big = Size(width: 5.0, height: 5.0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但是如果我们为它添加了自定义的初始化器，我们将失去自动生成的初始化器：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;struct Size {
    var width: Float
    var height: Float

    init(width: Float) {
        self.width = width
        self.height = width
    }
}

var big = Size(width: 5.0, height: 5.0) // error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以通过extension手动添加原来的初始化器，使它重新有效：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;extension Size {
    init(width: Float, height: Float) {
        self.width = width
        self.height = height
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个class、structure或enumeration的访问域可以和它们所遵守的protocol多访问域不同，但是它们实现的成员方法、变量和常量的访问域不能小于protocol的访问域，否则可能出现问题，例如在protocol级别的访问域内实现了对某class实例的type cast，却可能无法访问protocol对应的某个方法。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;internal protocol SimpleProtocl {
    func doSomthing()
}

private class ClassA: SimpleProtocl {
    func doSomthing() {}
}

public class ClassB: SimpleProtocl {
    func doSomthing() {}
}

internal class ClassC: SimpleProtocl {
    private func doSomthing() {} // error
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子类的访问域级别不能大于父类的访问域级别，但是子类的override成员的访问域级别不能小于对应的父类的成员访问域级别：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Animal {
    private func sleep() {}
    func move() {}
}

class Dog: Animal {
    override func sleep() {}
    private override func move() {} // error
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;带class关键字的protocol只能被class实现：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;proctocol SimpleProtocol: class {
    func doSomething()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果要在protocol声明optional成员，需要用&lt;code&gt;@objc&lt;/code&gt;(&lt;strong&gt;作用是什么？&lt;/strong&gt;)修饰protocol：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@objc protocol SimpleProtocol {
    optional func doSomething()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;
</content>
 </entry>
 
 <entry>
   <title>Swift学习备忘－需要研究的问题</title>
   <link href="http://blog.hipoplar.me/2015/06/swift-study-list.html"/>
   <updated>2015-06-09T00:00:00+08:00</updated>
   <id>/2015/06/swift-study-list</id>
   <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HeaderDoc:&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/HeaderDoc/intro/intro.html#//apple_ref/doc/uid/TP40001215-CH345-SW1&quot;&gt;1&lt;/a&gt;-&lt;a href=&quot;http://nshipster.com/swift-documentation/&quot;&gt;2&lt;/a&gt;-&lt;a href=&quot;http://nshipster.com/documentation/&quot;&gt;3&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optional类型&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var aString:String? = &amp;quot;Hello!&amp;quot;
var aString:Optional&amp;lt;String&amp;gt; = &amp;quot;Hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://nshipster.com/swift-literal-convertible/?utm_source=tuicool&quot;&gt;Swift Literal Convertibles&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Foundation框架是否用Swift重写了？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;enum实现protocol的方法&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;enum的raw-value的类型需要遵循literal convertible协议&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么class的成员方法可以修改成员变量的值，而值类型的成员方法&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html&quot;&gt;不可以&lt;/a&gt;修改成员变量的值，除非在func前添加&lt;code&gt;mutating&lt;/code&gt;修饰符？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@objc的意义和用法&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于protocol的extension，增加了约束条件（&lt;code&gt;where&lt;/code&gt;）和默认实现。如果针对统一个方法和属性有多个extension，应该怎么办？&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;
</content>
 </entry>
 
 <entry>
   <title>while loop在swift2中的语法</title>
   <link href="http://blog.hipoplar.me/2015/06/repeat-while-section.html"/>
   <updated>2015-06-09T00:00:00+08:00</updated>
   <id>/2015/06/repeat-while-section</id>
   <content type="html">&lt;p&gt;昨天WWDC大会发布了swift2，其中一个更新是关于while loop的&lt;/p&gt;

&lt;p&gt;原来语法是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var m = 2
do {
    m = m * 2
} while m &amp;lt; 100
print(m)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新后：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var m = 2
repeat {
    m = m * 2
} while m &amp;lt; 100
print(m)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
</content>
 </entry>
 
 <entry>
   <title>Swift中closure语法可以更精简</title>
   <link href="http://blog.hipoplar.me/2015/06/concise-closure.html"/>
   <updated>2015-06-09T00:00:00+08:00</updated>
   <id>/2015/06/concise-closure</id>
   <content type="html">&lt;p&gt;在Swift中调用数组的sorted方法进行排序时，需要传递一个函数类型的参数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;func sorted(isOrderedBefore: (T, T) -&amp;gt; Bool) -&amp;gt; [T]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数就是我们为数组排序定义的规则，以一个整数的数组为例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var numbers = [1, 19, 7, 12, 9, 30, 22]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们定义一个函数，并将其作为参数调用sorted方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;func compare(num1: Int, num2: Int) -&amp;gt; Bool {
    return num1 &amp;gt; num2
}

var nums5 = numbers.sorted(compare)

println(nums5)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果为：&lt;code&gt;[30, 22, 19, 12, 9, 7, 1]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果将参数改为闭包：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;numbers.sorted({(num1: Int, num2: Int) -&amp;gt; Bool in return num1 &amp;gt; num2})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于闭包的参数类型和返回值类型是有sorted方法确定了的，所以可以省略&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;numbers.sorted({ (num1, num2) in return num1 &amp;gt; num2 })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数个数也是确定的，也可以省略，并用$0、$1代替：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;numbers.sorted({ return $0 &amp;gt; $1 })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;return也可以省略：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;numbers.sorted({ $0 &amp;gt; $1 })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;numbers.sorted(&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最精简的结果是：可以用一行并且最少的代码完成排序！&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;自定义的带函数参数的方法，同样适用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;func sort(list: [Int], condition: ((Int, Int) -&amp;gt; Bool)) -&amp;gt; [Int] {
    var result = [Int]()
    result.append(list.first!)
    for i in 1..&amp;lt;list.count {
        for j in 0..&amp;lt;result.count {
            if condition(list[i], result[j]) {
                result.insert(list[i], atIndex: j)
                break
            }
            if j == list.count - 1 {
                result.append(list[i])
            }
        }
    }
    return result
}

sort(numbers, &amp;gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
</content>
 </entry>
 
 <entry>
   <title>Markdown</title>
   <link href="http://blog.hipoplar.me/2015/06/markdown-learning-note.html"/>
   <updated>2015-06-08T00:00:00+08:00</updated>
   <id>/2015/06/markdown-learning-note</id>
   <content type="html">&lt;p&gt;我们日常生活和工作中会进行很多书写活动，比如写信、写论文、写工作报告。通常书面材料都需要统一的格式，以便于阅读和传播。这些活动同样存在于互联网，html是一种格式，但是它毕竟是一种编码语言，对于工作重心在内容的人来说，编写一个html文件并不容易也没必要。Markdown实现了将一个普通的拥有一定格式的文本文件转换为html文件，进而符合格式的展现在浏览器或其他客户端上。&lt;/p&gt;

&lt;hr&gt;

&lt;h4&gt;什么是Markdown？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;一个用perl编写的程序&lt;/li&gt;
&lt;li&gt;用来将文本文件转换为html格式的文件&lt;/li&gt;
&lt;li&gt;规定了简易的语法，这些语法基于内容和书写习惯&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;在线教程&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://www.appinn.com/markdown/#p&quot;&gt;http://www.appinn.com/markdown/#p&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;程序源码&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;http://daringfireball.net/projects/markdown/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CSS Animation</title>
   <link href="http://blog.hipoplar.me/2015/06/css-animation.html"/>
   <updated>2015-06-08T00:00:00+08:00</updated>
   <id>/2015/06/css-animation</id>
   <content type="html">&lt;h3&gt;这是一个简单的CSS动画，你也可以在&lt;a href=&quot;http://blog.hipoplar.me/&quot;&gt;封面&lt;/a&gt;看到：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;页面载入时，图标从下至上移动并渐渐显示&lt;/li&gt;
&lt;li&gt;鼠标悬停在图标上时，图标放大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&quot;myGithub&quot; href=&quot;https://github.com/soda1015&quot; class=&quot;fa fa-github&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;实现这个动画需要一下技术：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Web Font（&lt;a href=&quot;http://fortawesome.github.io/Font-Awesome/&quot;&gt;Font Awesome&lt;/a&gt;-&lt;a href=&quot;http://www.bootcss.com/p/font-awesome/&quot;&gt;中文&lt;/a&gt;为例）&lt;/li&gt;
&lt;li&gt;CSS伪元素、伪类&lt;/li&gt;
&lt;li&gt;CSS过渡（&lt;code&gt;transition&lt;/code&gt;属性）、CSS动画（&lt;code&gt;@keyframes&lt;/code&gt;属性、&lt;code&gt;animation&lt;/code&gt;属性）&lt;/li&gt;
&lt;/ol&gt;

&lt;hr&gt;

&lt;h3&gt;Web Font&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Web Font是通过CSS3的&lt;code&gt;@font-face&lt;/code&gt;语句引入&lt;strong&gt;在线&lt;/strong&gt;的&lt;strong&gt;矢量&lt;/strong&gt;图形，它能够支持缩放，减少图片的流量消耗，并且可以重复利用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以&lt;a href=&quot;http://fortawesome.github.io/Font-Awesome/&quot;&gt;Font Awesome&lt;/a&gt;为例，下面将一个Github图标显示到网页上：&lt;/p&gt;

&lt;p&gt;引入在线CSS文件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; &amp;lt;link href=&amp;quot;//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签（也可以是其他标签）的&lt;code&gt;class&lt;/code&gt;属性设置为某个字体样式，如&lt;code&gt;fa fa-github&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; &amp;lt;a id=&amp;quot;githubIcon&amp;quot; href=&amp;quot;https://github.com/soda1015&amp;quot; class=&amp;quot;fa fa-github&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时为&lt;/p&gt;

&lt;p&gt;显示结果如下：&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;githubIcon&quot; href=&quot;https://github.com/soda1015&quot; class=&quot;fa fa-github&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为图标设置一下式样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#githubIcon {
    color: inherit;
    text-decoration: none;
    border-radius: 100%;
    border: solid 1px #333;
    display: block;
    font-size: 2.0em;
    height: 2.5em;
    line-height: 2.5em;
    position: relative;
    text-align: center;
    top: 0;
    margin: auto;
    width: 2.5em; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;githubIcon1&quot; href=&quot;https://github.com/soda1015&quot; class=&quot;fa fa-github&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;CSS伪元素和伪类&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;伪元素和伪类实际上是指两种选择器，选择器通过元素的标签名、类名或属性名获得该元素，如果某选择器没有对应的标签名、类名或属性名，而是通过某些特殊状态来获取元素，则该选择器为伪元素或伪类选择器。伪元素或伪类必须跟在某个选择器之后。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;:hover&lt;/code&gt;为伪类中的一种，它选择鼠标当前悬停位置的元素，并设置元素属性，例如，使它放大两倍：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#githubIcon:hover {
    font-size: 4em;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a id=&quot;githubIcon2&quot; href=&quot;https://github.com/soda1015&quot; class=&quot;fa fa-github&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;CSS过渡（transition属性）&lt;/h3&gt;

&lt;p&gt;刚刚的放大效果有些唐突，我们为图标设置&lt;code&gt;transition&lt;/code&gt;属性，使之有一个过渡：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#githubIcon {
    -moz-transition: all 0.2s ease-in-out;
    -webkit-transition: all 0.2s ease-in-out;
    -o-transition: all 0.2s ease-in-out;
    -ms-transition: all 0.2s ease-in-out;
    transition: all 0.2s ease-in-out;
    color: inherit;
    text-decoration: none;
    border-radius: 100%;
    border: solid 1px #333;
    display: block;
    font-size: 2.0em;
    height: 2.5em;
    line-height: 2.5em;
    position: relative;
    text-align: center;
    top: 0;
    margin: auto;
    width: 2.5em; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a id=&quot;githubIcon3&quot; href=&quot;https://github.com/soda1015&quot; class=&quot;fa fa-github&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;CSS动画（&lt;code&gt;@keyframes&lt;/code&gt;属性、&lt;code&gt;animation&lt;/code&gt;属性）&lt;/h3&gt;

&lt;p&gt;接下来，我们来添加一个动画效果：图标由下至上的移动，并逐渐显示&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为元素添加动画需要两步：1.定义动画；2.设置元素动画属性为定义的动画&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;定义动画&lt;code&gt;@keyframes&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@keyframes icon-animation {
    0% {
        -moz-transform: translate3d(0,1em,0);
        -webkit-transform: translate3d(0,1em,0);
        -o-transform: translate3d(0,1em,0);
        -ms-transform: translate3d(0,1em,0);
        transform: translate3d(0,1em,0);
        opacity: 0; }
    100% {
        -moz-transform: translate3d(0,0,0);
        -webkit-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1; } }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置动画属性&lt;code&gt;animation: icon-animation 1.5s infinite ease-in-out forwards;&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#githubIcon {
    -moz-transition: all 0.2s ease-in-out;
    -webkit-transition: all 0.2s ease-in-out;
    -o-transition: all 0.2s ease-in-out;
    -ms-transition: all 0.2s ease-in-out;
    transition: all 0.2s ease-in-out;
    -moz-animation: icon-animation 1.5s infinite ease-in-out forwards;
    -webkit-animation: icon-animation 1.5s infinite ease-in-out forwards;
    -o-animation: icon-animation 1.5s infinite ease-in-out forwards;
    -ms-animation: icon-animation 1.5s infinite ease-in-out forwards;
    animation: icon-animation 1.5s infinite ease-in-out forwards;
    color: inherit;
    text-decoration: none;
    border-radius: 100%;
    border: solid 1px #333;
    display: block;
    font-size: 2.0em;
    height: 2.5em;
    line-height: 2.5em;
    position: relative;
    text-align: center;
    top: 0;
    margin: auto;
    width: 2.5em; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，当鼠标悬停在图标上时，动画暂停&lt;code&gt;animation-play-state: paused;&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#githubIcon:hover {
    font-size: 4em;
    animation-play-state: paused;
    -moz-animation-play-state: paused;
    -webkit-animation-play-state: paused;
    -o-animation-play-state: paused;
    -ms-animation-play-state: paused;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a id=&quot;githubIcon4&quot; href=&quot;https://github.com/soda1015&quot; class=&quot;fa fa-github&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;更多好网站&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3.org/TR/css3-content/&quot;&gt;http://www.w3.org/TR/css3-content/&lt;/a&gt;：content属性与伪元素配合使用来生成内容，CSS3为content增加了更多特性。&lt;br&gt;
&lt;a href=&quot;https://cssanimation.rocks/cn/principles/&quot;&gt;https://cssanimation.rocks/cn/principles/&lt;/a&gt;：动画的十二个原则描述了动画能怎样用于让观众相信自己沉浸在现实世界中。&lt;br&gt;
&lt;a href=&quot;http://www.iconfont.cn&quot;&gt;http://www.iconfont.cn&lt;/a&gt;：阿里巴巴UX部门推出的矢量图标管理网站，也是国内首家推广Webfont形式图标的平台&lt;br&gt;
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/SVG&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/SVG&lt;/a&gt;：矢量图文件有不同的格式，可缩放矢量图形（Scalable Vector Graphics，SVG)是其中一种，它本质是xml。&lt;/p&gt;

&lt;hr&gt;
</content>
 </entry>
 
 
</feed>